### C++类型转换

#### 1 隐式类型转换

隐式类型转换自动执行，无需显式的操作符。

指针类型通常存在以下转换：

* 空指针可以转换到任意指针类型
* 任意指针类型都可以转换到`void*`指针
* 派生类指针可以转换到可访问的明确的基类指针，同时不改变const和volatile属性
* 一个C风格的数组隐式的把数组第一个元素转换成一个指针

#### 2 显式类型转换

（关键字`explicit`可以阻止未经允许的经过转换构造函数进行隐式转换的情况发生。）

1. static_cast
2. const_cast
3. reinterpret_cast
4. dynamic_cast

##### 21 static_cast

```C++
static_cast<new_type>(expression)
```

主要应用场景：

* 用于类层次结构中基类和派生类之间的指针或引用的转换。进行上行转换（把派生类的指针或引用转换成基类的）是安全的。进行下行转换（把基类的指针或引用转换成派生类的）由于没有动态类型检查，所以是不安全的。
* 把空指针转换成目标类型的空指针（不安全!）。
* 把任何类型的表达式转换成void类型。
* 转换为右值引用。
* 用于C++内置数据类型之间的相互转换。

static_cast强制转换只会在编译时检查，没有运行时类型检查来保证转换的安全性。同时，static_cast不能转换掉表达式的const、volatile或者_unaligned属性。

static_cast强制转换如果涉及到类，只能在**有相互联系的类型中进行相互转换**，但类不一定包含虚函数。

##### 22 dynamic_cast

```C++
dynamic_cast<new_type>(expression)
```

dynamic_cast不能用于内置数据类型的强制转换，它用于对类类型对象的强制转换，因此new_type必须是指针或者引用或者指向void的指针。如果new_type是指针，则expression的类型必须是指针；如果new_type是引用，则expression为左值。如果转换成功则返回转型对象的指针或者引用，转换失败则返回null（转型对象为指针时）或者抛出异常（转型对象为引用时）。

dynamic_cast使用运行时类型信息(RTTI)来进行类型安全检查，而static_cast转换在编译时完成。

使用dynamic_cast进行转换的类，**基类中一定要有虚函数**，否则编译不通过。因为类中存在虚函数说明有想要让基类指针指向（或基类对象引用）派生类对象的情况，此时转换才有意义。同时，由于运行时的类型检查需要运行时的类型信息，而类的类型信息存储在虚函数表中，只有定义了虚函数的类才有虚函数表。

在类层次结构间进行上行转换时，dynamic_cast和static_cast的效果是一样的。在进行下行转换时，dynamic_cast具有动态类型检查功能，比static_cast更安全。向下转换能否成功还与转换的目标类型有关，即被转换对象的类型要与转换的目标类型相同，否则转换失败。因此dynamic_cast的作用还有确保转换的结果指向/引用完整的目标类型对象和确认被转换对象的类型与目标类型是相同的。

##### 23 const_cast

在C语言中，const限定符通常被用来限定变量，表示该变量的值不能被修改。而const_cast用来强制去掉这种不能被修改的const特性。但需要注意的是**const_cast不是用于去除变量的常量性，而是去除指向常量对象的指针或引用的常量性**。

```C++
const_cast<new_type>(expression)
```

new_type必须是指针、引用或者指向类成员的指针。new_type的类型和expression的类型是一样的。常量指针/引用被转化成非常量指针/引用，并且仍然指向/引用原来的对象。

了解这种转换即可。

##### 24 reinterpret_cast

```C++
reinterpret_cast<new_type>(expression)
```

reinterpret_cast用于转换指针、引用、函数指针的类型。new_type必须是一个指针、引用、算术类型、函数指针或成员指针。

了解这种转换即可。
