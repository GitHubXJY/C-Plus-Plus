### 左值/右值、右值引用、移动语义/完美转发

1. 1 变量、指针、引用
2. 2 左值和右值
3. 3 左值引用和右值引用
4. 4 值语义
5. 51 移动语义
6. 52 std::move()
7. 61 完美转发（万能引用 引用折叠）
8. 62 std::forward()

#### 1 变量、指针、引用

```C++
int var=0;
int* ptr=&var;
int& ref=var;
cout<< &ref; // 0x0000xxx0
cout<< &ptr; // 0x0000xxx8
cout<< &ref; // 0x0000xxx0
typeid(var).name(); // int
typeid(ptr).name(); // int*
typeid(ref).name(); // int
```

变量`var`在程序运行时会占用一块内存空间，假设这块内存空间的地址为`0xvvvv`，编译器通过变量名使用这块内存空间（绑定），这块内存空间的存放的内容为变量的值。

指针`ptr`也是变量（指针变量），它也占用一块内存空间，假设地址为`0xpppp`，这块内存空间的内容是指针变量所指向的变量的内存空间的地址值（`0xvvvv`）。

引用`ref`是变量的一个别名，从上面的代码来看，它不占用内存空间，因为`&ref`的值和`&var`的值相同，即变量`ref`的内存地址值和变量`var`的内存地址值相同，是同一块内存空间（而不是`ref`占用的内存空间所存放的内容是`var`占用的内存空间的地址值）。浅显的来理解：引用变量不占用内存，引用变量和被引用变量绑定到同一块内存空间。但这是编译器的优化，实际上引用变量会占用内存。

#### 2 左值和右值

在C++03中：每个表达式要么是左值，要么是右值。重要的是：左值和右值是表达式的属性，而不是对象的属性。左值是命名在单个表达式之外持续存在的对象，如`obj`，`*ptr`，`arr[i]`，`++x`。右值是它们所在的完整表达式末尾处消失的临时值，如`1234`，`x+y`，`string("hello")`，`x++`。

确定表达式是否为左值的另一种方法是是否能获取它的地址，如果能那么它是一个左值，否则为右值。获取持久对象的地址是可行的，但获取临时对象的地址是危险的，因为临时对象很快就会消失。因此，左值：可以取地址的，有名字的，非临时的，它占用某个可确定位置（地址）的内存。右值：无法取地址的，没有名字的，临时的，一般是不可寻址的常量表达式，或是在表达式求值过程中创建的无名临时对象（没有可识别的内存位置，或存在于计算过程中的临时寄存器里）。

左值既能够出现在等号左边，也能出现在等号右边，一般可以被修改；右值只能出现在等号右边，不能被修改。左值可以用左值和右值赋值，右值不能被赋值。当左值对象被用作左值时，用的是对象的身份（在内存中的位置），被用作右值时，用的是对象的值（内容）。

**左值和右值都是可修改或不可修改的**。右值不应与常量对象混淆，右值并不意味着该对象是不可修改的，类类型的右值可以通过其成员函数修改其内容。一般来说，检测到可修改的右值可以让我们进行“资源移动”，如果可修改右值的对象拥有资源（如内存），那么可以对它们进行“资源移动”而不是复制它们，因为它们无论如何都会消失，通过获取可修改的右值所拥有的内容来构造或分配这些右值通常称为移动。

**C++11将右值分为纯右值和将亡值**。纯右值就是C++98标准中右值的概念，如非引用返回的函数的临时变量值、一些运算表达式产生的临时变量、不跟对象关联的字面值，这些值都不能取地址。**将亡值是C++11新增的和右值引用相关的表达式**，这样的表达式通常是将要移动的对象、T&&函数的返回值、std::move()函数的返回值等。

右值不能直接转换为左值，但右值可以通过一些显式的方法产生左值，如一元解引用操作符`*`需要一个右值参数，但返回一个左值结果：

```C++
int arr[]={1,2,3};
int* p=&arr[0];
*(p+1)=10;
// (p+1)  rvalue
// *(p+1) lvalue
```

相反的，一元左值取地址操作符`&`需要一个左值参数，返回一个右值：

```C++
int var=10;
int* p1=&var; // ok
int* p2=&(var+1); // error
// (var) lvalue
// (&var) rvalue
```

#### 3 左值引用和右值引用

左值引用就是C++11之前所说的引用。左值引用在汇编层面其实和普通的指针一样，定义引用变量必须初始化，因为引用其实是一个别名，需要告诉编译器定义的是谁的引用。

```C++
int var=0;
int& ref1=var;
ref=20;
int &ref2=10; // error
```

error：无法对10进行取地址操作，因为在汇编中无法对立即数取地址，立即数没有在内存中存储，而是存储在寄存器中。

```C++
const int& ref3=10; // ok
```

ok：使用常引用来引用常量数字10，因为此时内存上产生的临时变量保存了10，这个临时变量可以进行取地址操作。此时`ref3`引用的是这个临时变量。

右值引用通过在某种数据类型后面放置`&&`来实现，它绑定到一个临时变量（右值），不能将non-const左值绑定到右值。和左值引用一样，右值引用不会发生拷贝。**绑定到右值的右值引用，其变量本身是一个左值**。

```C++
int var=0;
int&  ref1=var; // OK
int&& ref2=var; // error
int&  ref3=11; // error
int&& ref4=11; // OK
```

对象的创建和销毁由编译器在幕后控制，程序员只能确保在本行代码有效的，就是右值。而由用户创建的，通过作用域规则可知其生存期的，就是左值。**右值引用绑定到右值，绑定后本来会被销毁的右值的生存期延长为绑定到它的右值引用的生存期**。在汇编层面右值引用的操作和常引用相同，即产生临时变量来存储常量。

右值引用的作用是利用右值（特别是临时对象）来减少对象构造和析构操作。

```C++
SomeType foo(){
    return SomeType(...);
}
SomeType s1 = foo(); // C++11 之前
SomeType &&s2 = foo(); // C++11
```

上述代码中，在C++11之前只能通过编译器优化RVO/NRVO的方式来提升性能，如果不满足编译器的优化条件，还是只能通过拷贝的方式进行操作。在C++11引入右值引用后，如果不满足RVO/NRVO条件，也能通过避免拷贝延长临时变量的生命周期达到优化的目的。

右值引用只能绑定右值，对于左值，该如何进行优化。为此，引入了移动语义。

#### 4 值语义

值语义(value semantics)指目标对象由原对象拷贝生成，且生成后与原对象完全无关，彼此独立存在互不影响。C++的内置类型（bool、int、char、）都是值语义，标准库里的 complex<>、pair<>、vector<>、string等类型也都是值语义，拷贝之后就与原对象脱离关系。

与值语义对应的是对象语义(object semantics)，或者叫做对象语义(reference semantics)。对象语义指的是面向对象意义下的对象，对象拷贝是禁止的。例如 muduo里的 Thread是对象语义，拷贝 Thread是无意义且被禁止的。

对于用户自定义的类，如果一个类`C`具有值语义，那么：

* C的size在编译时可以确定。
* 将C类型的变量c1赋值给另一个变量c2，无需专门的`operator()=`，简单的bit-wise-copy即可。
* 当上述赋值关系发生后，c1和c2脱离关系：c1和c2可以独立销毁，其内存也可以独立释放。

值语义是C++语言的三大约束之一，为了让用户定义的类型(class)能像内置类型一样具有同等地位，C++做了如下设计：

* C++中class的设计和C的struct一样，没有额外的开销，定义一个只包含一个int成员的类的对象开销和定义一个int一样。
* 类的数据成员默认是未初始化的。
* 类的数组是一个个类对象挨着，没有额外的indirection。
* 编译器会为类默认生成拷贝构造函数和重载赋值运算符。
* 当把类类型传入函数时，默认是进行复制（除非参数声明为reference）。

一般定义一个类，如果不提供自定义的拷贝构造函数，编译器会默认提供一个拷贝构造函数，但编译器提供的拷贝构造函数是浅拷贝，将传入的同类型对象的所有成员变量的值赋值给当前创建的对象的各个成员。遇到类成员变量是指针类型时，由于会直接将指针本身的值拷贝过去，导致有几个指针指向同一片内存，导致最后对象析构时会对同一片内存区域释放多次。当我们设计的类管理着某些资源的时候（成员有指针类型），就需要自定义拷贝构造函数，将指针变量的拷贝修改成深拷贝。这样新对象和原对象完全脱离关系，互不影响。

C++中有四个特殊的成员函数：默认构造函数、析构函数，拷贝构造函数，拷贝赋值运算符。如果开发人员没有定义这四个成员函数，那么编译器则在满足某些特定条件下(仅在需要的时候才生成，比如某个代码使用它们但是它们没有在类中明确声明)自动生成。这些由编译器生成的特殊成员函数是public且inline。

自C++11起，引入了另外两个特殊的成员函数：移动构造函数和移动赋值运算符。如果开发人员没有显示定义移动构造函数和移动赋值运算符，那么编译器也会生成默认。与其他四个特殊的成员函数不同，编译器生成默认的移动构造函数和移动赋值运算符满足以下条件：

* 如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数(这三者之一，表示程序员要自己处理对象的复制或释放问题)，编译器就不会为它生成默认的移动构造函数或者移动赋值运算符，这样做的目的是防止编译器生成的默认移动构造函数或者移动赋值运算符不是开发人员想要的。
* 如果一个类没有定义自己的移动构造函数和移动赋值运算符，且编译器不会生成默认的，那么在代码中通过std::move()调用的移动构造/移动赋值的行为将被转换为调用拷贝构造/赋值运算符。
* 只有一个类没有显示定义拷贝构造函数、赋值运算符以及析构函数，且类的每个非静态成员都可以移动时，编译器才会生成默认的移动构造函数或者移动赋值运算符。
* 如果显式声明了移动构造函数或移动赋值运算符，则拷贝构造函数和拷贝赋值运算符将被隐式删除（因此程开发人员必须在需要时实现拷贝构造函数和拷贝赋值运算符）。

与拷贝操作一样，如果开发人员定义了移动操作，那么编译器就不会生成默认的移动操作，但是编译器生成移动操作的行为和生成拷贝操作的行为有些许不同，如下：

* 两个拷贝操作是独立的：声明一个不会限制编译器生成另一个。所以如果你声明一个拷贝构造函数，但是没有声明拷贝赋值运算符，如果写的代码用到了拷贝赋值，编译器会帮助你生成拷贝赋值运算符。同样的，如果你声明拷贝赋值运算符但是没有拷贝构造函数，代码用到拷贝构造函数时编译器就会生成它。上述规则在C++98和C++11中都成立。
* 两个移动操作不是相互独立的。如果你声明了其中一个，编译器就不再生成另一个。比如，如果你给类声明了一个移动构造函数，就表明对于移动操作应该怎样实现与编译器默认生成的有些区别。如果成员移动构造有些问题，那么成员移动赋值同样也可能有问题。所以声明移动构造函数阻止编译器生成默认的移动赋值运算符，声明移动赋值运算符同样阻止编译器生成默认的移动构造函数（除非全部由自己实现）。

```C++
class SomeType{......};
void foo1(SomeType st){
    // do something
}
SomeType foo2(){
    SomeType ret_st;
    return ret_st;
}
int main(){
    SomeType __st1;
    foo1(__st1);

    foo2();
}
```

在上面的代码中，函数foo1()的参数是SomeType类型的对象，当调用foo()函数时，会通过调用SomeType的拷贝构造函数，根据对象__st1拷贝构造出对象st。函数foo2()的返回值是SomeType类型，当foo2()函数结束后，又会调用SomeType的拷贝构造函数，根据对象ret_st拷贝构造出foo2()函数返回的临时对象。

编译器知道何时调用拷贝构造函数或者赋值运算符进行值传递，如果涉及到底层资源，如内存或socket，需要实现自己的拷贝构造函数和赋值运算符以实现深拷贝，有时拷贝的代价很大，如当我们使用STL容器的时候会涉及到大量的拷贝操作。

如果上述代码中对象__st1在语句`foo(__st1);`后面确定不再被使用，那么根据对象__st1拷贝构造出一个新的对象st，使用复制品st而不是利用以后不再被使用的__st1的资源，是不明智的。同时，如果要利用foo2()函数返回的临时对象，这个临时对象是借助对象ret_st拷贝构造的，如果直接使用对象ret_st的资源而不是让其在foo2()函数结束后被析构掉转而使用它的复制品（临时对象），将会更好。

C++中基于值语义的拷贝构造和赋值拷贝，会导致对资源密集型对象的不必要拷贝，大量的拷贝很可能会成为程序的性能瓶颈。C++11重新定义了左值和右值，并允许函数对这两种不同的类型进行重载。通过对右值的重新定义，实现了移动语义(move semantics)和完美转发(perfect forwarding)。

#### 51 移动语义

移动语义不是试图取代复制语义，也不是以任何方式破坏它。相反，它旨在增强复制语义。**移动语义主要是性能优化：将昂贵的对象从内存中的一个地址移动到另外一个地址的能力，同时窃取源资源以便以最小的代价构建目标**。

在C++11之前，当进行值传递时，编译器会隐式的调用拷贝构造函数。自C++11起，通过右值引用来避免由于拷贝调用而导致的性能损失 。**使用右值引用的最常见的方式是创建移动构造函数和重载移动赋值运算符**。移动构造函数与拷贝构造函数一样，将对象的实例作为其参数，并基于原始对象创建一个新的实例。但是，移动构造函数可以避免内存重新分配，因为移动构造函数的参数是一个右值引用，也可以说是一个临时对象，而临时对象在调用之后就被销毁不再被使用。因此，在移动构造函数中对参数的内容进行移动而不是拷贝。

移动语义通过移动构造函数和移动赋值运算符实现，与拷贝构造函数的区别是：

* 参数的符号必须是右值引用符号，即`&&`。
* 参数不可以是常量，因为函数内需要修改参数的值。
* 指向参数的资源的指针在资源转移后需要修改（确保它不再和将要被转移的资源有关联），避免临时对象的析构函数将资源释放掉，否则这是拷贝而不是修改。

```C++
class C{
private:
    int length;
    int* ptr;
public:
    // 构造函数
    C(int _len){
        length=_len;
        ptr=new int[length];
    }
    // 析构函数
    ~C(){
        length=0;
        delete[]ptr;
    }
    // 拷贝构造函数
    C(const C& other){
        length=other.length;
        ptr=new int[length];
        ptr=copy(other.ptr);
    }
    // 赋值运算符
    C& operator=(C& other){
        if(this!=other){
            length=other.length;
            delete[]ptr;
            ptr=new int[length];
            ptr=copy(other.ptr);
        }
        return *this;
    }
    // 移动构造函数
    C(C&& other){
        length=other.length;
        ptr = other.ptr;
        other.length=0;
        other.ptr=nullptr;
    }
    // 移动赋值运算符
    C& operator=(C&& other){
        if(this!=&other){
            delete[]ptr;
            length=other.length;
            ptr=other.ptr;
            other.length=0;
            other.ptr=nullptr;
        }
        return *this;
    }
}
```

移动构造函数不会分配新的资源，也不会复制其它资源，而是移动other中的资源。也就是说，它窃取了other中资源，然后将other设置为其默认构造的状态。如果数据成员ptr很大，且other不会再被使用，如果使用原来的拷贝构造函数，就需要挨个进行复制。而使用移动构造函数，没有额外的资源分配，仅仅是将其它对象的资源进行移动占为己有。赋值运算符同理。

#### 52 std::move()

如果需要调用移动构造函数和移动赋值运算符，就需要用到右值。如果要对一个左值使用移动语义，自C++11起，标准库提供一个函数`std::move()`，用于将左值转换为右值。

`std::move()`函数并不移动任何东西，它只是进行类型转换，真正进行资源移动的操作需要自己实现。

`std::move()`进行简单的类型转换：

* 如果传递的是左值，则推导为左值引用，然后由`static_cast`转换为右值引用。
* 如果传递的是右值，则推导为右值引用，然后由`static_cast`转换为右值引用。

使用`std::move()`之后意味着两点：**原对象不再被使用，如果对其使用会造成不可预知的后果。所有权转移，资源的所有权被转移给新的对象。**

自C++11起，开始支持右值引用，标准库中很多容器都支持移动语义，以`std::vector<T>`为例，`vector::push_back()`定义了两个重载版本，一个参数类型为`T&`的左值参数版本，一个参数类型为`T&&`的右值参数版本。

```C++
std::vector<SomeType>v;

SomeType sm(20);
v.push_back(sm); // push_back(T&)
// 参数是左值，解析为push_back(T&)。如果想要避免拷贝操作，可以使用move()函数来实
// 现（前提是SomeType类型中实现了移动语义）。
v.push_back(std::move(sm)); // push_back(T&&)

v.push_vack(SomeType(10));
// 参数是右值，解析为push_back(T&&)，使用移动构造函数将资源从实参移动到vector内部
// 的对象中。而在C++11之前，上述代码生成实参的拷贝，然后调用SomeType的拷贝构造函数。
```

借助`swap()`函数辅助理解：

```C++
void swap(T& a,T& b){
    T tmp=a; // 调用拷贝构造函数
    a=b; // 调用operator=
    b=tmp; // 调用operator=
}
```

如果T是含有指针的复合数据类型，则上述转换会调用一次拷贝构造函数和两次赋值运算符重载。

使用`std::move()`函数：

```C++
void swap(T& a,T& b){
    T tmp=std::move(a);
    a=std::move(b);
    b=std::move(tmp);
}
```

如果T是可移动的，那么整个操作将非常高效。如果T是不可移动的，那么它和普通的swap()一样，调用一次拷贝和两次赋值操作。

#### 61 完美转发

##### 引用折叠

C++的引用折叠规则：对于一个值引用的引用最终都会被折叠成左值引用或右值引用。

```C++
T& &   -> T&  // 左值引用的左值引用是左值引用
T& &&  -> T&  // 左值引用的右值引用是左值引用
T&& &  -> T&  // 右值引用的左值引用是左值引用
T&& && -> T&& // 右值引用的右值引用是右值引用
```

##### 万能引用

万能引用(universal reference)，也称为未定义引用，如果一个变量或参数被声明为`T&&`，**并且需要推导`T`的类型**，那么该变量或参数即为万能引用。

左值引用只能绑定到左值上（const左值引用可以绑定到右值上），右值引用只能绑定到右值上。万能引用既可以绑定到左值，也可以绑定到右值。和其它引用一样，万能引用必须进行初始化，而**用来初始化万能引用的值的类型决定了它到底是左值引用还是右值引用**。

应用场景：函数模板，auto自动类型推导。

```C++
template <typename T> // 模板
void fun1(T&& pat){   // 万能引用
    // do something
}
fun1(10);   // 自动类型推导：12是右值，T为int类型，pat为int&&类型
int var=20;
fun1(var);  // 自动类型推导：var是左值，T为int&类型，pat为(int& &&)->int&类型
```

注意区分右值引用和万能引用。（**类型T不需要推导，类型U需要推导!!!**）

```C++
template <typename T>
class cl{
    void foo2(T&& pat); // 右值引用
    
    template <typename U>
    void foo3(U&& pat); // 万能引用
}
```

const会剥夺万能引用资格

```C++
template <typename T>
void foo4(T&& pat); // 万能引用

template <typename T>
void foo5(const T&& pat);   // 右值引用
```

##### 完美转发

绑定到万能引用上的对象可以是左值也可以是右值，当它接收一个右值时，它是一个右值引用，而右值引用本身是一个左值。

在程序的执行过程中，对于引用的传递可能会有额外的隐式转换，一个右值引用参数经过函数的调用转发可能会转换成左值引用（在参数传递过程中给右值分配内存空间导致其变成一个左值），这是不希望的结果，我们希望在参数传递过程中保持右值的属性。

我们希望：如果参数传递的是左值，转发的就是左值引用，传递的是右值，转发的就是右值引用

std::forward()的作用是实现完美转发，确保转发过程中引用的类型不发生任何改变，左值引用转发后还是左值引用，右值引用转发后还是右值引用。

#### 62 std::forward()

std::move和std::forward实际上并没有真正的move或forward任何数据或资源，只是对数据的类型进行强制的cast，以达到逻辑上的区分是左值引用还是右值引用，实际上要做的事情还需要额外的实现。
